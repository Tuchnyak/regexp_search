# Техническое задание: Скрипт для поиска по регулярному выражению

## 1. Назначение

Разработать скрипт на Python для рекурсивного поиска текста в файлах по заданному регулярному выражению внутри указанной директории. Скрипт должен быть кроссплатформенным (Windows, Linux).

## 2. Запуск и аргументы

Скрипт запускается из командной строки.

### Аргументы:

1.  `directory_path` (обязательный): Путь к директории, в которой будет производиться поиск.
2.  `search_regex` (обязательный): PCRE-совместимое регулярное выражение для поиска текста. Может включать многострочные шаблоны.
3.  `exclude_files_regex` (необязательный): Регулярное выражение для исключения файлов из поиска по их **имени**. Не применяется к директориям.

### Пример вызова:

```bash
python search_script.py "/path/to/search" "import\s+java\.util\.\w+" ".*\.log"
```

## 3. Логика работы

### 3.1. Обход директорий

- Скрипт должен рекурсивно обойти все поддиректории, начиная с `directory_path`.

### 3.2. Фильтрация файлов

- **По расширению:** Обрабатываются только файлы с расширениями из жестко заданного в коде списка (белый список):
  - `java`, `txt`, `sql`, `yaml`, `properties`, `md`, `gradle`, `py`
- **По регулярному выражению исключения:** Файлы, чьи имена совпадают с `exclude_files_regex` (если он задан), должны быть пропущены.

### 3.3. Чтение и обработка файлов

- **Определение кодировки:** Скрипт должен определить ОС и использовать соответствующий порядок определения кодировки:
  - **Windows:** 1. `windows-1251`, 2. `cp866`, 3. `utf-8`.
  - **Linux/macOS:** 1. `utf-8`.
- **Поиск совпадений:** Содержимое файла читается целиком, и в нем ищется одно или несколько совпадений с `search_regex`. Поддерживаются многострочные совпадения.

## 4. Вывод в консоль

- **В процессе работы:**
  - `Просмотр файла: /path/to/file.txt...`
  - `Найдено совпадений: 5`
- **Ошибки:**
  - Сообщения об ошибках доступа к поддиректориям или файлам.
  - Сообщения о невозможности прочитать файл из-за кодировки.
- **По завершении:**
  - Если были найдены совпадения или возникли ошибки: `Работа завершена. Результаты сохранены в файл: YYYYMMDD_HHmm_result_....json`
  - Если совпадений не найдено и ошибок не было: `Поиск завершен. Совпадений не найдено.`

## 5. Файл результатов

### 5.1. Условия создания

- Файл с результатами создается **только** если было найдено хотя бы одно совпадение ИЛИ произошла хотя бы одна ошибка при обработке.

### 5.2. Именование

- Файл сохраняется в директорию, переданную в `directory_path`.
- Шаблон имени: `ГГГГММДД_ЧЧмм_result_<первые_15_символов_search_regex>.json`.
  - Небезопасные для имени файла символы из регулярного выражения должны быть удалены или заменены.

### 5.3. Структура (JSON)

```json
{
  "search_regex": "import\\s+java\\.util\\.\\w+",
  "exclude_regex": ".*\\.log",
  "results": {
    "/полный/абсолютный/путь/к/файлу1.txt": [
      "Строка целиком, в которой было найдено совпадение.",
      "Другая строка с совпадением."
    ],
    "/полный/абсолютный/путь/к/файлу2.java": [
      "// Полная строка, даже если совпадение - часть строки.",
      "public class MyClass { // Многострочное совпадение будет включать все затронутые строки."
    ]
  },
  "errors": [
    {
      "path": "/полный/абсолютный/путь/к/проблемной/папке",
      "reason": "Отказано в доступе"
    },
    {
      "path": "/полный/абсолютный/путь/к/файлу_с_кодировкой.txt",
      "reason": "Не удалось определить кодировку"
    }
  ]
}
```
- `search_regex`: Полное регулярное выражение поиска, переданное при запуске.
- `exclude_regex`: Регулярное выражение исключения (может быть `null`).
- `results`: Объект, где ключ - это полный абсолютный путь к файлу, а значение - массив строк. Каждая строка в массиве - это полная строка из исходного файла, в которой было найдено одно или несколько совпадений.
- `errors`: Массив объектов, каждый из которых описывает ошибку доступа к файлу/директории или ошибку чтения.

## 6. Обработка ошибок

- **Стартовая директория:** Если `directory_path` не существует или недоступен, скрипт должен вывести сообщение об ошибке в консоль и немедленно завершить работу с ненулевым кодом возврата.
- **Вложенные директории/файлы:** Если в процессе обхода возникает ошибка доступа к поддиректории или файлу, информация об этом логируется в консоль и добавляется в секцию `errors` итогового JSON-файла. Скрипт продолжает работу.
- **Ошибки кодировки:** Если не удалось прочитать файл ни одной из подходящих для ОС кодировок, информация об этом логируется в консоль и добавляется в секцию `errors`. Скрипт продолжает работу.

## 7. План тестирования

Для проверки корректности работы скрипта необходимо подготовить тестовую среду, включающую:

1.  **Тестовая структура директорий:**
    - Вложенные папки (2-3 уровня).
    - Папка, к которой нет прав на чтение (`chmod 000`).
2.  **Набор тестовых файлов:**
    - Файлы с расширениями из белого списка (`.txt`, `.java`) и вне его (`.log`, `.dat`).
    - Файлы с искомым текстом (одно и несколько совпадений).
    - Файлы без искомого текста.
    - Файл с многострочным совпадением.
    - Пустые файлы.
    - Файлы в разных кодировках (`UTF-8`, `Windows-1251`, `CP866`).
    - Файл, к которому нет прав на чтение (`chmod 000`).
3.  **Сценарии тестирования:**
    - **"Счастливый путь":** Запуск с корректными параметрами, находит несколько совпадений в разных файлах. Проверить корректность JSON-отчета.
    - **Ничего не найдено:** Запуск с регулярным выражением, которое ничему не соответствует. Проверить, что файл отчета не создается, а в консоли выводится соответствующее сообщение.
    - **Исключение файлов:** Запуск с использованием `exclude_files_regex`. Проверить, что файлы, подпадающие под маску, исключены из поиска.
    - **Ошибка доступа:** Запуск на директории, содержащей недоступную папку/файл. Проверить, что ошибка корректно отражена в консоли и в секции `errors` JSON-отчета.
    - **Ошибка кодировки:** Проверить, что файл с неподдерживаемой кодировкой вызывает ошибку, которая логируется в `errors`.
    - **Проверка имени файла:** Убедиться, что имя генерируемого файла соответствует шаблону.
    - **Кросс-платформенность:** Выполнить ключевые тесты на Windows и Linux, чтобы убедиться в правильной работе логики определения кодировок.

```json
{
  "results": {
    "/полный/абсолютный/путь/к/файлу1.txt": [
      "Первое найденное совпадение (может быть многострочным).\nСохраняются все переносы строк.",
      "Второе найденное совпадение."
    ],
    "/полный/абсолютный/путь/к/файлу2.java": [
      "Единственное совпадение в этом файле."
    ]
  },
  "errors": [
    {
      "path": "/полный/абсолютный/путь/к/проблемной/папке",
      "reason": "Отказано в доступе"
    },
    {
      "path": "/полный/абсолютный/путь/к/файлу_с_кодировкой.txt",
      "reason": "Не удалось определить кодировку"
    }
  ]
}
```